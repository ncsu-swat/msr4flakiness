/**
 * Ensures that valid flag combinations appear visually correct, and invalid show in hex.  This
 * also demonstrates how sparse the lookup table is.
 */
@Test
public void allFormattedFlagsWithValidBits() {
    // Highest valid flag is 0x20.
    List<String> formattedFlags = new ArrayList<>(0x40);
    for (byte i = 0; i < 0x40; i++) formattedFlags.add(Http2.INSTANCE.formatFlags(TYPE_HEADERS, i));
    assertThat(formattedFlags).containsExactly("", "END_STREAM", "00000010", "00000011", "END_HEADERS", "END_STREAM|END_HEADERS", "00000110", "00000111", "PADDED", "END_STREAM|PADDED", "00001010", "00001011", "00001100", "END_STREAM|END_HEADERS|PADDED", "00001110", "00001111", "00010000", "00010001", "00010010", "00010011", "00010100", "00010101", "00010110", "00010111", "00011000", "00011001", "00011010", "00011011", "00011100", "00011101", "00011110", "00011111", "PRIORITY", "END_STREAM|PRIORITY", "00100010", "00100011", "END_HEADERS|PRIORITY", "END_STREAM|END_HEADERS|PRIORITY", "00100110", "00100111", "00101000", "END_STREAM|PRIORITY|PADDED", "00101010", "00101011", "00101100", "END_STREAM|END_HEADERS|PRIORITY|PADDED", "00101110", "00101111", "00110000", "00110001", "00110010", "00110011", "00110100", "00110101", "00110110", "00110111", "00111000", "00111001", "00111010", "00111011", "00111100", "00111101", "00111110", "00111111");
}
